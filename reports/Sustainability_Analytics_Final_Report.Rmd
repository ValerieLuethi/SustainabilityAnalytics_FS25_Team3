---
title: "Sustainability Analytics: Project Report Group 2"
subtitle: "Effect of Climate Change on Great Aletsch Glacier and the village of Brig"
author:
  - name: "Vani Gupta"
    affiliation: "Hochschule Luzern"
    email: "vani.gupta@stud.hslu.ch"
  - name: "Ramona Kölliker"
    affiliation: "Hochschule Luzern"
    email: "ramona.kölliker@stud.hslu.ch"
  - name: "Valérie Lüthi"
    affiliation: "Hochschule Luzern"
    email: "valerie.lüthi@stud.hslu.ch"
  - name: "Alois Wagner"
    affiliation: "Hochschule Luzern"
    email: "alois.wagner@stud.hslu.ch"
date: "2025-09-05"
output:
  html_document:
    number_sections: true
    theme: lumen
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    toc-title: Table of Content
  minidown::mini_document:
    result_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<u>**Loading R-Packages**</u>
```{r Loading_Packages, include=TRUE, warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
#Loading needed packages
library(dplyr)
library(forecast)
library(ggplot2)
library(lubridate)
library(tidyr)
library(tseries)  # for working with time series
library(ismev)    # for EVT gev.fit
library(tidyverse)# for data handling (includes ggplot2, dplyr, tidyr, readr, lubridate)
library(evd)      # for calculating HQ values in EVT
library(zoo)      # for function 'yearmon'
```

# Introduction (Ramona)

<br><p style="font-size: 35px;"> Introduction </p><br>

Hinweis für Ramona: Falls wir für die Einleitung oder Abstrakt keine Auflistung im Inhaltsverzeichnis haben möchten, könnten wir das mit **'p style="font-size: 35px;"> Introduction </p'** anstelle von **## Introduction** lösen.


# Datapreparation/Cleaning

<u>**Loading Data**</u>
```{r loading_data, include= TRUE, echo=TRUE}
# Reading in data
# for massa, rhone and glacier: why are the processed csv loaded instead of the raw data?
raw_massa <- read.csv('../data/processed/massa_cleaned.csv', header=TRUE, sep=',', na.strings='-')
raw_rhone <- read.csv('../data/processed/rhone_cleaned.csv', header=TRUE, sep=',', na.strings='-')
raw_glacier <- read.csv('../data/processed/glacier_cleaned.csv', header=TRUE, sep=',', na.strings='-')
raw_glacier_monthly <- read.csv('../data/processed/glacier_monthly_processed.csv', header=TRUE, sep=',', na.strings='-')
raw_jungfraujoch <- read.csv("../data/raw/weather_monthly_jungfraujoch.csv", header=TRUE, sep=';', na.strings='-')
raw_brigrain <- read.csv('../data/raw/weather_rain_monthly_brig.csv', header=TRUE, sep=';', na.strings='-')

```


## Jungfraujoch Temperature (Valerie)
The homogeneous data series from the Jungfraujoch climate station is available on demand via [MeteoSchweiz OpenData](https://www.meteoswiss.admin.ch/services-and-publications/service/open-data.html). The station is located 3571 meters above sea level and located in the Aletsch area. We were interested in the measurement of the homogeneous monthly mean temperature covering the time span from 01/01/1933 to 01/07/2025. The temperature in Celsius was measured 2 meters above ground.

## River Massa (Ramona)
## Glacier (Vani)


# Exploratory Data Analysis (Vani)


# Stationarity

## Temperature Jungfraujoch (Valérie)
### Datapreparation
The raw Jungfraujoch weather data set was prepared by first converting the reference_timestamp column into a proper datetime format. Then the data set was reduced to the columns necessary for our analysis (station_abbr, reference_timestamp, temp_mean_C). For clarity columns were renamed. A check for missing values, confirmed that there were none. Finally a time series object of the mean temperature values was created, specifying the start and end dates as well as the monthly frequency. 
<u>**Jungfraujoch temperature data preparation**</u>
```{r jungfraujoch_temperature_data_preparation, include = TRUE}
# convert timestamp to datetime format
df_jungfraujoch <- raw_jungfraujoch %>%
  mutate(reference_timestamp = dmy_hm(reference_timestamp))
# only keep columns needed for analysis
df_jungfraujoch_reduced <- df_jungfraujoch %>% 
  select(station_abbr, reference_timestamp, ths200m0)
# rename columns
colnames(df_jungfraujoch_reduced) <- c('station_abbr', 'reference_timestamp', 'temp_mean_C')
# check for NAs
colSums(is.na(df_jungfraujoch_reduced)) # no NAs
# create time series object
# temp_mean monthly series
ts_jungfraujoch <- ts(df_jungfraujoch_reduced$temp_mean_C,
                      start = c(1933, 1),
                      end = c(1933 + (nrow(df_jungfraujoch_reduced)-1) %/% 12,
                              (nrow(df_jungfraujoch_reduced)-1) %% 12 + 1),
                      frequency = 12)
str(ts_jungfraujoch)
```
A look at the summary statistics reveals that monthly mean temperatures at Jungfraujoch are predominantly below freezing, ranging from extremely cold (-21.7 C°) to just above freezing (3.5 C°). This is consistent with the high-altitude alpine climate.
The plot of monthly mean temperatures shows clear seasonal oscillations, with cold winters and milder summers. There is also a slight upward trend, suggesting that the mean tempertures might increase gradually over the years. This could hint at the climate getting warmer.
<u>**Jungfraujoch temperature data exploration**</u>
```{r jungfraujoch_temperature_data_exploration, include = TRUE}
summary(ts_jungfraujoch)
plot(ts_jungfraujoch, main="Jungfraujoch Monthly Mean Temperature", ylab="°C", xlab="Year")
```
### Stationarity
We further check the stationarity of the time series by inspecting the ACF and PACF. The ACF shows a strong seasonal pattern reflecting the annual temperature cycle. The PACF indicates that monthly mean temperatures are influenced by the previous month (lag 1). Then shows a negative connection for the next few months (lags 2 to 6) and a positive connection again (lags 8 to 13). This is likely due to temperature changes following a seasonal pattern, where each month corresponds to a specific period (e.g. season). 
<u>**Jungfraujoch ACF and PACF**</u>
```{r jungfraujoch_temperature_acf_pacf, include = TRUE}
# acf and pacf
acf(ts_jungfraujoch) # acf indicates seasonality
pacf(ts_jungfraujoch) # damped sinusoid
```
To further analyze the time series, we applied Seasonal-Trend decomposition using Loess (STL). STL separates the time series into trend, seasonal and remainder components, which is useful to identify and remove sesanality and trends before time series modelling. Different variations of the s.window parameter were tested to control the smoothness of the seasonal component. Additionaly the t.window parameter was used to control the smoothing of the trend component. We observed that larger seasonal windows slightly reduced autocorrelations in the remainder, whereas the PACF improved notably when using a large trend window. An s.window of 37 and a t.window of 121 showed the most satisfying result.
The Augmented-Dickey-Fuller test was used to formally check stationarity of the remainder. The significant result (p < .01) indicates stationarity.
<u>**Jungfraujoch Temperature STL Decomposition**</u>
```{r jungfraujoch_temperature_stl_decomposition, include = TRUE}
# decomposition with stl
ts_jungfraujoch_stl <- stl(ts_jungfraujoch, s.window = "periodic") # assumes strong, stable seasonality
plot(ts_jungfraujoch_stl, main = "s.window periodic")
ts_jungfraujoch_stl_13 <- stl(ts_jungfraujoch, s.window = 13) # 1 year smooth
plot(ts_jungfraujoch_stl_13, main = "s.window = 13")
ts_jungfraujoch_stl_25 <- stl(ts_jungfraujoch, s.window = 25) # 2 year smooth
plot(ts_jungfraujoch_stl_25, main = "s.window = 25")
ts_jungfraujoch_stl_37 <- stl(ts_jungfraujoch, s.window = 37) # 3 year smooth
plot(ts_jungfraujoch_stl_37, main = "s.window = 37")
ts_jungfraujoch_stl_37_121 <- stl(ts_jungfraujoch, s.window = 37, t.window=121) # 3 year smooth
plot(ts_jungfraujoch_stl_37_121, main = "s.window = 37, t.window=121")
ts_jungfraujoch_stl_49 <- stl(ts_jungfraujoch, s.window = 49)
plot(ts_jungfraujoch_stl_49)

remainder_periodic <- ts_jungfraujoch_stl$time.series[, "remainder"]
acf(remainder_periodic, main = "ACF of STL remainder, periodic")
pacf(remainder_periodic, main = "PACF of STL remainder, periodic")

remainder_13 <- ts_jungfraujoch_stl_13$time.series[, "remainder"]
acf(remainder_13, main = "ACF of STL remainder, s.window = 13")
pacf(remainder_13, main = "PACF of STL remainder, s.window = 13")

remainder_25 <- ts_jungfraujoch_stl_25$time.series[, "remainder"]
acf(remainder_25, main="ACF of STL remainder, s.window = 25")
pacf(remainder_25, main = "PACF of STL remainder, s.window = 25")

remainder_37 <- ts_jungfraujoch_stl_37$time.series[, "remainder"]
acf(remainder_37, main = "ACF of STL remainder, s.window = 37") # ACF lags 2 and 5 persist
pacf(remainder_37, main = "PACF of STL remainder, s.window = 37")

remainder_37_121 <- ts_jungfraujoch_stl_37_121$time.series[, "remainder"]
acf(remainder_37_121)
pacf(remainder_37_121) # no change compared to without t.window

# augmented dickey fuller test to check stationarity formally
adf.test(remainder_37_121)
```
For further modelling a data frame containing the components of the decomposed time series as well as the observed data was created and saved.
<u>**Jungfraujoch create cleaned data frame**</u>
```{r jungfraujoch_temperature_clean_df, include = TRUE}
# Extract components
components <- ts_jungfraujoch_stl_37_121$time.series
# Create a time index (Date or Year-Month depending on your ts object)
dates <- time(ts_jungfraujoch)
# Build a data frame
df_jungfraujoch_processed <- data.frame(
  date       = dates,
  observed   = as.numeric(ts_jungfraujoch),
  trend      = as.numeric(components[, "trend"]),
  seasonal   = as.numeric(components[, "seasonal"]),
  remainder  = as.numeric(components[, "remainder"])
)
# create processed data file
write.csv(df_jungfraujoch_processed, "../data/processed/jungfraujoch_temperature.csv", row.names = FALSE)
# RDS
saveRDS(df_jungfraujoch_processed, "../data/processed/jungfraujoch_temperature.rds")
```

## Rainfall Brig (Alois)

### Datapreparation

<u>**Brig rain data preparation**</u>
```{r brig_rain_data_preparation, include = TRUE}
raw_brigrain$Date <- as.Date(raw_brigrain$reference_timestamp, format = "%d.%m.%Y")

df_rain <- raw_brigrain %>% select(Date, rhs150m0)
#plot(df_rain)

# defining starting year and month
start_year_brig  <- year(min(df_rain$Date))
start_month_brig <- month(min(df_rain$Date))

# creating ts-object on a monthly basis
rain_ts <- ts(df_rain$rhs150m0,
              start = c(start_year_brig, start_month_brig),
              frequency = 12)   # 12 month per year
```


### Stationarity with stl

<u>**Brig rain stl**</u>
```{r brig_rain_stl, include = TRUE}
stl_1 <- stl(rain_ts, s.window =122, t.window=115)
plot(stl_1)
remainder_stl1 <- stl_1$time.series[,"remainder"]
adf.test(remainder_stl1)
acf(remainder_stl1, main = "ACF of residuals / Brig Rain / stl")
pacf(remainder_stl1, main = "PACF of residuals / Brig Rain / stl")
```

<u>**Brig creating dataframe with stl prepared data**</u>
```{r brig_rain_dataframe_stl, include = TRUE}
#Creating dataframe of the prepared data
rain_decomp_df <- data.frame(
  Date      = as.Date(as.yearmon(time(rain_ts))),  # month data
  Original  = as.numeric(rain_ts),                 # Raw Data
  Trend     = stl_1$time.series[,"trend"],         # Trend-Componente
  Seasonal  = stl_1$time.series[,"seasonal"],      # Saisonal-Component
  Remainder = stl_1$time.series[,"remainder"]      # Remainder
)

head(rain_decomp_df)  # for checking

#saveRDS(rain_decomp_df, file = "rain_decomposition.rds")
```




## River Massa
### Waterlevel (Ramona)


## River Rhone
### Waterlevel (Ramona)

### Watervolume (Alois)

<u>**watervolume Data Preparation**</u>
```{r watervolume_massa_preparation, echo=FALSE}
# Read data
df_massa <- raw_massa

## Time Series Massa River - daily data
freq_daily <- 365.2422

ts_watervolume_massa <- ts(df_massa$discharge_vol_m3s, 
              start = c(year(min(df_massa$date_yyyymmdd)),
                        yday(min(df_massa$date_yyyymmdd))), 
              frequency = freq_daily)


# creating dataframe out of ts_watervolume_massa
#----------------------------
# defining start date
massa_start_date <- as.Date("1981-01-01")
# length of time series
n <- length(ts_watervolume_massa)
# creating date
massa_dates <- seq.Date(from = massa_start_date, by = "day", length.out = n)

df_massa_prep <- data.frame(
  Date = massa_dates,
  Watervolume = ts_watervolume_massa
)

#----------------------------------------------------------------------
#----------------------------------------------------------------------
#First insights of massa data / creating ts

#plotting massa data / watervolume
#plot(ts_watervolume_massa, main = "Massa daily discharge volume in m^3/s 1980 - 2020")
```

#### Monthly average Massa

<u>**Creating monthly average values for massa**</u>
```{r monthly_average_massa, include = TRUE}
# calculation average monthly watervolume
df_massa_monthly <- df_massa %>%
  mutate(Year = year(date_yyyymmdd),
         Month = month(date_yyyymmdd)) %>%
  group_by(Year, Month) %>%
  summarise(
    discharge_monthly_mean = mean(discharge_vol_m3s, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(Date = as.Date(paste(Year, Month, "01", sep = "-")))
  
## Time Series Massa River - monthly data
ts_watervolume_monthly <- ts(df_massa_monthly$discharge_monthly_mean, 
              start = c(year(min(df_massa_monthly$Date)),
                        month(min(df_massa_monthly$Date))), 
              frequency = 12)


plot(ts_watervolume_monthly, main = "Massa mean discharge volume in m^3/s 1980 - 2020")
```

##### Stationarity with stl

<u>**Stationarity with stl approach**</u>
```{r stl_monthly_massa, include = TRUE}
ts_watervolume_monthly_stl <- stl(ts_watervolume_monthly, s.window = 24, t.window=365.2422)
remainder_ts_watervolume_monthly_stl <- ts_watervolume_monthly_stl$time.series[,"remainder"]
acf(remainder_ts_watervolume_monthly_stl, main = "ACF of residuals watervolume massa / monthly average / stl")
pacf(remainder_ts_watervolume_monthly_stl, main = "PACF of residuals watervolume massa / monthly average / stl")
plot(remainder_ts_watervolume_monthly_stl, main = "Residuals watervolume massa / monthly average / stl")
adf.test(na.omit(remainder_ts_watervolume_monthly_stl))
plot(ts_watervolume_monthly_stl)
```

<u>**Creating massa stationary dataframe**</u>
```{r stl_monthly_massa_dataframe, include = TRUE}
#Creating dataframe of the prepared data
massa_monthly_mean_stl <- data.frame(
  Date      = as.Date(paste(df_massa_monthly$Year, df_massa_monthly$Month, "01", sep = "-")),  # monthly date
  Original  = as.numeric(ts_watervolume_monthly),                 # original data
  Trend     = ts_watervolume_monthly_stl$time.series[,"trend"],         # trend component
  Seasonal  = ts_watervolume_monthly_stl$time.series[,"seasonal"],      # seasonal component
  Remainder = ts_watervolume_monthly_stl$time.series[,"remainder"]      # remainder
)

head(massa_monthly_mean_stl)  # for checking

# # CSV export
# write.csv(
#   massa_monthly_mean_stl, 
#   "stationary_monthly_mean_watervolume_massa.csv", 
#   row.names = FALSE
# )
# 
# # RDS export
# saveRDS(
#   massa_monthly_mean_stl, 
#   "stationary_monthly_mean_watervolume_massa.rds"
# )
```

# Merge Data
For convenience for further modelling we merged the preprocessed datasets jungfraujoch_temperature, glacier_mass_balance, mass_waterlevel and brig_rain by the date column. Due to different start and end dates we chose to keep the overlapping time period (01/01/1981 to 01/12/2020) in order to get a complete dataset.

<u>**Merge data*</u>
```{r merge_data, include = TRUE}
# laod data
df_jungfrau <- readRDS("../data/processed/jungfraujoch_temperature.rds")
df_glacier <- readRDS("../data/processed/glacier_monthly_processed.rds")
df_waterlevel <- readRDS("../data/processed/waterlevel_det_stoch.rds")
df_precipitation <- readRDS("../data/processed/rain_decomposition.rds")
# convert date columns to identical format
# jungfrau
# Number of rows
n <- nrow(df_jungfrau)

# Create monthly sequence from start year/month
start_date <- as.Date("1933-01-01")
df_jungfrau <- df_jungfrau %>%
  mutate(Date = seq.Date(from = start_date, by = "month", length.out = n))
# glacier
df_glacier <- df_glacier %>%
  mutate(Date = as.Date(year_month))
# waterlevel
# Map German month abbreviations to month numbers
month_map <- c(
  "Jan" = 1, "Feb" = 2, "Mär" = 3, "Apr" = 4,
  "Mai" = 5, "Jun" = 6, "Jul" = 7, "Aug" = 8,
  "Sep" = 9, "Okt" = 10, "Nov" = 11, "Dez" = 12
)

df_waterlevel <- df_waterlevel %>%
  mutate(
    # split year_month into month abbreviation and year
    Month = sapply(strsplit(year_month, " "), `[`, 1),
    Year  = as.numeric(sapply(strsplit(year_month, " "), `[`, 2)),
    Month = month_map[Month],                        # map to numeric month
    Date  = as.Date(paste0(Year, "-", Month, "-01")) # create Date
  ) %>%
  select(-Month, -Year, -year_month)  # remove helper columns
# precipiation
str(df_precipitation) # already in right format

# merge by dates, full outer join
df_merged <- df_jungfrau %>%
  select(Date, observed, trend, seasonal, remainder) %>%
  full_join(df_glacier %>%
              select(Date, mass_balance_monthly, trend, seasonal, deterministic, stochastic),
            by = "Date", suffix = c("_jungfrau", "_glacier")) %>%
  full_join(df_waterlevel %>%
              select(Date, waterlevel_m, trend, seasonal, deterministic, stochastic),
            by = "Date", suffix = c("", "_waterlevel")) %>%
  full_join(df_precipitation %>%
              select(Date, Original, Trend, Seasonal, Remainder),
            by = "Date", suffix = c("", "_precipitation")) %>%
  arrange(Date)

# rename columns
df_merged <- df_merged %>%
  rename(
    # Jungfrau
    observed_jungfrau = observed,
    trend_jungfrau = trend_jungfrau,
    seasonal_jungfrau = seasonal_jungfrau,
    remainder_jungfrau = remainder,
    
    # Glacier
    mass_balance_glacier = mass_balance_monthly,
    trend_glacier = trend_glacier,
    seasonal_glacier = seasonal_glacier,
    deterministic_glacier = deterministic,
    stochastic_glacier = stochastic,
    
    # Waterlevel
    waterlevel = waterlevel_m,
    trend_waterlevel = trend,
    seasonal_waterlevel = seasonal,
    deterministic_waterlevel = deterministic_waterlevel,
    stochastic_waterlevel = stochastic_waterlevel,
    
    # Precipitation
    precipitation = Original,
    trend_precipitation = Trend,
    seasonal_precipitation = Seasonal,
    remainder_precipitation = Remainder
  )

# select same time span
# Find first and last date of each dataset
start_jungfrau <- min(df_merged$Date[!is.na(df_merged$observed_jungfrau)])
end_jungfrau   <- max(df_merged$Date[!is.na(df_merged$observed_jungfrau)])

start_glacier  <- min(df_merged$Date[!is.na(df_merged$mass_balance_glacier)])
end_glacier    <- max(df_merged$Date[!is.na(df_merged$mass_balance_glacier)])

start_water    <- min(df_merged$Date[!is.na(df_merged$waterlevel)])
end_water      <- max(df_merged$Date[!is.na(df_merged$waterlevel)])

start_precip   <- min(df_merged$Date[!is.na(df_merged$precipitation)])
end_precip     <- max(df_merged$Date[!is.na(df_merged$precipitation)])

# Overlapping date range
start_overlap <- max(start_jungfrau, start_glacier, start_water, start_precip)
end_overlap   <- min(end_jungfrau, end_glacier, end_water, end_precip)

df_merged_overlap <- df_merged %>%
  filter(Date >= start_overlap & Date <= end_overlap)

str(df_merged_overlap)
head(df_merged_overlap)
colSums(is.na(df_merged_overlap))
any(is.na(df_merged_overlap)) # no NAs

# create processed data file
write.csv(df_merged_overlap, "../data/processed/df_merged.csv", row.names = FALSE)
# RDS
saveRDS(df_merged_overlap, "../data/processed/df_merged.rds")

```
# Modelling

## Cross-Correlation Analysis
To investigate potential linear relationships between the different time series, we use the cross-correlation function (ccf). For this we only need the stationary remainder components of each time series, since we want to avoid spurious correlations caused by trends and seasonal components. 
<u>**Create dataframe for Cross-Correlation Analysis**</u>
```{r dataframe_ccf, include = TRUE, warning=FALSE, message=FALSE}
# select the columns relevant for cross-correlation analysis
df_ccf <- df_merged_overlap %>%
  select(
    Date,
    remainder_jungfrau,
    remainder_precipitation,
    stochastic_glacier,
    stochastic_waterlevel
  )
# convert back to time series objects
# Number of observations
n <- nrow(df_ccf)
# Create time series objects (monthly frequency)
# Example: temperature and glacier mass balance
start_year <- year(min(df_ccf$Date))
start_month <- month(min(df_ccf$Date))

# Create monthly time series objects
temp_ts <- ts(df_ccf$remainder_jungfrau,
              start = c(start_year, start_month),
              frequency = 12)

glacier_ts <- ts(df_ccf$stochastic_glacier,
                 start = c(start_year, start_month),
                 frequency = 12)
precip_ts <- ts(df_ccf$remainder_precipitation,
                start = c(start_year, start_month),
                frequency = 12)

waterlevel_ts <- ts(df_ccf$stochastic_waterlevel,
                    start = c(start_year, start_month),
                    frequency = 12)
```

<u>**CCF Jungfraujoch Temperature & Glacier Mass Balance**</u>
```{r ccf_jungfraujoch_temperature_glacier_mass_balance, include = TRUE, warning=FALSE, message=FALSE}
temp_scaled <- scale(temp_ts)
glacier_scaled <- scale(glacier_ts)
plot(temp_scaled, type="l", col="orange", lwd=2, ylab="Scaled value", xlab="Time")
lines(glacier_scaled, col="blue", lwd=2)
legend("topright", legend=c("Temperature Jungfraujoch", "Glacier Mass Balance"), col=c("orange","blue"), lty=1)
ccf(glacier_ts, temp_ts) # temperature leads
ccf(temp_ts, glacier_ts) # glacier leads
```

# Extreme Value Theory (EVT)
<u>**EVT Massa Histogram**</u>
```{r EVT_histogram_massa, include = TRUE, warning=FALSE, message=FALSE}
# histogram
p_massa <- ggplot(df_massa_prep, aes(x=Watervolume)) + 
  geom_histogram() +
  ggtitle("Histogramm of massa watervolume in m^3/s")
plot(p_massa)
```

#### Plotting lm-trend line

<u>**EVT Massa Data Preparation**</u>
```{r EVT_massa, include = TRUE, warning=FALSE, message=FALSE}
# defining trend lm
massa_t_lm <- lm(Watervolume ~ Date, data = df_massa_prep)

# defining trend lm with extrem values
threshold <- quantile(df_massa_prep$Watervolume, 0.95)  # upper 5%-quantile
massa_ex <- subset(df_massa_prep, Watervolume > threshold)

massa_ex_t_lm <- lm(Watervolume ~ Date, data = massa_ex)

# storing lm coef in dataframe
trend_df <- data.frame(
  intercept = c(coef(massa_t_lm)[1], coef(massa_ex_t_lm)[1]),
  slope     = c(coef(massa_t_lm)[2], coef(massa_ex_t_lm)[2]),
  type      = c("Trend with all values", "Trend with extreme values")
)

# Plotting raw data with trend lines
ggplot(df_massa_prep, aes(x = Date, y = Watervolume)) +
  geom_line(color = "black") +
  geom_abline(data = trend_df,
              aes(intercept = intercept, slope = slope, color = type),
              size = 1) +
  labs(title = "Watervolum with trend lines",
       x = "Year", y = expression("m"^3*"/s"),
       color = "Trend type") +
  theme_minimal()
```

#### EVT Peaks over Threshold (POT)

<u>**EVT POT massa**</u>
```{r EVT_modeling_threshold_massa, include = TRUE}
#EVT original data on upper quantil
threshold_massa_evt <- quantile(df_massa_prep$Watervolume, 0.998)
massa_ex <- df_massa_prep %>% filter(df_massa_prep$Watervolume > threshold_massa_evt)
massa_ex_fit <- gev.fit(massa_ex$Watervolume)
gev.diag(massa_ex_fit) # -> Return Period is on a daily scale
massa_ex_fit$mle
```

#### EVT Block Max Year 

<u>**EVT Block max year massa**</u>
```{r EVT_modeling_block_max_massa, include = TRUE}
#-----------------
#EVT original data block max year

df_massa_prep <- df_massa_prep %>%
  mutate(Date = massa_start_date + (Date - min(Date)))  # Time as day offset

massa_max_year <- df_massa_prep %>%
  mutate(YEAR = year(Date),
         MONTH = month(Date)) %>%
  group_by(YEAR) %>%
  summarize(Watervolume_MAX = max(Watervolume, na.rm = TRUE)) %>%
  ungroup()

massa_max_year_fit <- gev.fit(massa_max_year$Watervolume_MAX)
gev.diag(massa_max_year_fit) # -> Return Period is on a yearly scale
massa_max_year_fit$mle
```

#### EVT HQ Values

<u>**EVT HQ block max Massa**</u>
```{r EVT_modeling_hq_massa, include = TRUE}
# Outputting HQ Values
# -> -> Hochwasser-Quantil / Hochwasserabluss: flood quantil for a defined return interval
# -> HQ2 means the watervolume will be achieved/exceeded each 2 years

loc_massa <- massa_max_year_fit$mle[1]
scale_massa <- massa_max_year_fit$mle[2]
shape_massa <- massa_max_year_fit$mle[3]

# return periode in years
return_periods_massa <- c(2, 10, 30, 100, 300)

# probability p = 1 - 1/T
p <- 1 - 1 / return_periods_massa


# calculating HQ-Value
HQ_massa <- qgev(p, loc=loc_massa, scale=scale_massa, shape=shape_massa)

# output
hq_table_massa <- data.frame(ReturnPeriod = return_periods_massa, HQ = HQ_massa)
hq_table_massa
```


### River Rhone
#### First data analysis rhone

<u>**EVT Rhone Data Preparation**</u>
```{r evt_rhone_preparation, echo=FALSE}
# Read data
df_rhone <- raw_rhone

## Time Series Rhone River - daily data
freq_daily <- 365.2422

ts_watervolume_rhone <- ts(df_rhone$discharge_vol_m3s, 
              start = c(year(min(df_rhone$date_yyyymmdd)),
                        yday(min(df_rhone$date_yyyymmdd))), 
              frequency = freq_daily)


# creating dataframe out of ts_watervolume_rhone 
#----------------------------
# defining start date
rhone_start_date <- as.Date("1981-01-01")
# length of time series
n <- length(ts_watervolume_rhone)
# creating date
rhone_dates <- seq.Date(from = rhone_start_date, by = "day", length.out = n)

df_rhone_prep <- data.frame(
  Date = rhone_dates,
  Watervolume = ts_watervolume_rhone
)

#----------------------------------------------------------------------
#----------------------------------------------------------------------
#First insights of rhone data / creating ts

#plotting rhone data / watervolume
plot(ts_watervolume_rhone, main = "Rhone daily discharge volume in m^3/s 1980 - 2020")
```

<u>**EVT Rhone Histogram**</u>
```{r EVT_histogram_rhone, include = TRUE, warning=FALSE, message=FALSE}
# histogram
p_rhone <- ggplot(df_rhone_prep, aes(x=Watervolume)) + 
  geom_histogram() +
  ggtitle("Histogramm of rhone watervolume in m^3/s")
plot(p_rhone)
```

#### Plotting lm-trend line

<u>**EVT Rhone Data Preparation**</u>
```{r EVT_rhone, include = TRUE, warning=FALSE, message=FALSE}
# defining trend lm
rhone_t_lm <- lm(Watervolume ~ Date, data = df_rhone_prep)

# defining trend lm with extrem values
threshold <- quantile(df_rhone_prep$Watervolume, 0.95)  # upper 5%-quantile
rhone_ex <- subset(df_rhone_prep, Watervolume > threshold)

rhone_ex_t_lm <- lm(Watervolume ~ Date, data = rhone_ex)

# storing lm coef in dataframe
trend_df <- data.frame(
  intercept = c(coef(rhone_t_lm)[1], coef(rhone_ex_t_lm)[1]),
  slope     = c(coef(rhone_t_lm)[2], coef(rhone_ex_t_lm)[2]),
  type      = c("Trend with all values", "Trend with extreme values")
)

# Plotting raw data with trend lines
ggplot(df_rhone_prep, aes(x = Date, y = Watervolume)) +
  geom_line(color = "black") +
  geom_abline(data = trend_df,
              aes(intercept = intercept, slope = slope, color = type),
              size = 1) +
  labs(title = "Watervolum with trend lines",
       x = "Year", y = expression("m"^3*"/s"),
       color = "Trend type") +
  theme_minimal()
```




#### EVT Peaks over Threshold (POT)

<u>**EVT POT Rhone**</u>
```{r EVT_modeling_threshold_rhone, include = TRUE}
#EVT original data on upper quantil
threshold_rhone_evt <- quantile(df_rhone_prep$Watervolume, 0.998)
rhone_ex <- df_rhone_prep %>% filter(df_rhone_prep$Watervolume > threshold_rhone_evt)
rhone_ex_fit <- gev.fit(rhone_ex$Watervolume)
gev.diag(rhone_ex_fit) # -> Return Period is on a daily scale
rhone_ex_fit$mle
```

#### EVT Block Max Year 

<u>**EVT Block max year Rhone**</u>
```{r EVT_modeling_block_max_rhone, include = TRUE}
#-----------------
#EVT original data block max year

df_rhone_prep <- df_rhone_prep %>%
  mutate(Date = rhone_start_date + (Date - min(Date)))  # Time as day offset

rhone_max_year <- df_rhone_prep %>%
  mutate(YEAR = year(Date),
         MONTH = month(Date)) %>%
  group_by(YEAR) %>%
  summarize(Watervolume_MAX = max(Watervolume, na.rm = TRUE)) %>%
  ungroup()

rhone_max_year_fit <- gev.fit(rhone_max_year$Watervolume_MAX)
gev.diag(rhone_max_year_fit) # -> Return Period is on a yearly scale
rhone_max_year_fit$mle
```

#### EVT HQ Values

<u>**EVT HQ block max Rhone**</u>
```{r EVT_modeling_hq_rhone, include = TRUE}
# Outputting HQ Values
# -> -> Hochwasser-Quantil / Hochwasserabluss: flood quantil for a defined return interval
# -> HQ2 means the watervolume will be achieved/exceeded each 2 years

loc_rhone <- rhone_max_year_fit$mle[1]
scale_rhone <- rhone_max_year_fit$mle[2]
shape_rhone <- rhone_max_year_fit$mle[3]

# return periode in years
return_periods_rhone <- c(2, 10, 30, 100, 300)

# probability p = 1 - 1/T
p <- 1 - 1 / return_periods_rhone


# calculating HQ-Value
HQ_rhone <- qgev(p, loc=loc_rhone, scale=scale_rhone, shape=shape_rhone)

# output
hq_table_rhone <- data.frame(ReturnPeriod = return_periods_rhone, HQ = HQ_rhone)
hq_table_rhone
```

### EVT conclusion



# Conclusion

# Outlook (Vani)


# Disclaimer for AI


# Appendix






























# Examples for formatting

<u>**Datapreparation of Brig_Rain dataset**</u>
```{r rain_brig_datapreparation, include=TRUE, warning=FALSE, message=FALSE, echo=TRUE, results='hide'}
#code
```
## H2

### H3 {#chapter-with-features}

<u>**----->"Header for the Code Block1<------**</u>
```{r first_subset_feature_exp, include=TRUE, warning=FALSE, message=FALSE, echo=TRUE}
#code
```
<u>**----->"Header for the Code Block1<------**</u>
```{r first_subset_feature_exp1, include=TRUE, warning=FALSE, message=FALSE, echo=TRUE}
#code
```

The [feature explanation](#Table_feature_exp) can be found in the appendix.






## Appendix

### Feature Explanation of the dataset {#Table_feature_exp}

This section provides further explanations for the dataset.

```{r data_dict, include=TRUE, warning=FALSE, message=FALSE, echo=TRUE}

```

[Back to Chapter 'H3'](#chapter-with-features)
